diff --git a/Makefile.common b/Makefile.common
index 0313fbeaa0..a843d77f76 100644
--- a/Makefile.common
+++ b/Makefile.common
@@ -2317,6 +2317,8 @@ ifeq ($(HAVE_CRTSWITCHRES), 1)
          OBJ += $(DEPS_DIR)/switchres/custom_video_xrandr.o
          DEFINES += -DSR_WITH_XRANDR
       endif
+#      OBJ += $(DEPS_DIR)/switchres/custom_video_drmkms.o
+#      DEFINES += -DSR_WITH_KMSDRM
    endif
    ifneq ($(findstring Win32,$(OS)),)
       DEFINES += -DSR_WIN32_STATIC
diff --git a/deps/switchres/switchres_wrapper.cpp b/deps/switchres/switchres_wrapper.cpp
index d92c55bc7c..57012131af 100644
--- a/deps/switchres/switchres_wrapper.cpp
+++ b/deps/switchres/switchres_wrapper.cpp
@@ -16,6 +16,7 @@
 #include "switchres.h"
 #include "switchres_wrapper.h"
 #include "log.h"
+#include "modeline.h"
 #include <stdio.h>
 #include <locale>
 #ifdef __cplusplus
@@ -39,11 +40,11 @@ MODULE_API void sr_load_ini(char* config) {
 }
 
 
-MODULE_API unsigned char sr_init_disp(const char* scr) {
+MODULE_API unsigned char sr_init_disp(const char* scr, int i) {
 	if (scr)
 		swr->set_screen(scr);
 	swr->add_display();
-	if (!swr->display()->init())
+	if (i > 0 && !swr->display()->init())
 		return 0;
 	return 1;
 }
@@ -68,8 +69,25 @@ MODULE_API void sr_set_user_mode(int width, int height, int refresh) {
 }
 
 
+void best_mode_to_sr_modeline(display_manager* disp, sr_modeline* modeline)
+{
+	modeline->pclock  = disp->best_mode()->pclock;
+	modeline->hactive = disp->best_mode()->hactive;
+	modeline->hbegin  = disp->best_mode()->hbegin;
+	modeline->hend    = disp->best_mode()->hend;
+	modeline->htotal  = disp->best_mode()->htotal;
+	modeline->vactive = disp->best_mode()->vactive;
+	modeline->vbegin  = disp->best_mode()->vbegin;
+	modeline->vend    = disp->best_mode()->vend;
+	modeline->vtotal  = disp->best_mode()->vtotal;
+	modeline->vfreq   = disp->best_mode()->vfreq;
+	modeline->type    = disp->best_mode()->type;
+}
+
+
 void disp_best_mode_to_sr_mode(display_manager* disp, sr_mode* srm)
 {
+	sr_modeline* srml = &(srm->modeline);
 	srm->width = disp->width();
 	srm->height = disp->height();
 	srm->refresh = disp->v_freq();
@@ -78,6 +96,7 @@ void disp_best_mode_to_sr_mode(display_manager* disp, sr_mode* srm)
 	srm->x_scale = disp->x_scale();
 	srm->y_scale = disp->y_scale();
 	srm->interlace = (disp->is_interlaced() ? 105 : 0);
+	best_mode_to_sr_modeline(disp, &(srm->modeline));
 }
 
 
diff --git a/deps/switchres/switchres_wrapper.h b/deps/switchres/switchres_wrapper.h
index c31da657b9..38f671f88e 100644
--- a/deps/switchres/switchres_wrapper.h
+++ b/deps/switchres/switchres_wrapper.h
@@ -75,6 +75,24 @@ char* LIBERROR()
 #endif
 
 /* That's all the exposed data from Switchres calculation */
+typedef struct MODULE_API
+{
+	uint64_t    pclock;
+	int    hactive;
+	int    hbegin;
+	int    hend;
+	int    htotal;
+	int    vactive;
+	int    vbegin;
+	int    vend;
+	int    vtotal;
+	//
+	double vfreq;
+	//
+	int    type;
+	//
+} sr_modeline;
+
 typedef struct MODULE_API {
 	int width;
 	int height;
@@ -84,6 +102,7 @@ typedef struct MODULE_API {
 	int x_scale;
 	int y_scale;
 	unsigned char interlace;
+	sr_modeline modeline;
 } sr_mode;
 
 
@@ -91,7 +110,7 @@ typedef struct MODULE_API {
 MODULE_API void sr_init();
 MODULE_API void sr_load_ini(char* config);
 MODULE_API void sr_deinit();
-MODULE_API unsigned char sr_init_disp(const char* src);
+MODULE_API unsigned char sr_init_disp(const char* src, int i);
 MODULE_API unsigned char sr_add_mode(int, int, double, unsigned char, sr_mode*);
 MODULE_API unsigned char sr_switch_to_mode(int, int, double, unsigned char, sr_mode*);
 MODULE_API void sr_set_monitor(const char*);
@@ -110,7 +129,7 @@ typedef struct MODULE_API {
     void (*init)(void);
     void (*sr_sr_load_ini)(char*);
     void (*deinit)(void);
-    unsigned char (*sr_init_disp)(const char*);
+    unsigned char (*sr_init_disp)(const char*, int);
     unsigned char (*sr_add_mode)(int, int, double, unsigned char, sr_mode*);
     unsigned char (*sr_switch_to_mode)(int, int, double, unsigned char, sr_mode*);
     void (*sr_set_monitor)(const char*);
diff --git a/gfx/drivers_context/drm_ctx.c b/gfx/drivers_context/drm_ctx.c
index a8268cf964..a40078767e 100644
--- a/gfx/drivers_context/drm_ctx.c
+++ b/gfx/drivers_context/drm_ctx.c
@@ -116,47 +116,111 @@ typedef struct hdmi_timings
 static enum gfx_ctx_api drm_api           = GFX_CTX_NONE;
 static drmModeModeInfo gfx_ctx_crt_switch_mode;
 
+static float mode_vrefresh(drmModeModeInfo *mode)
+{
+	return  mode->clock * 1000.00
+			/ (mode->htotal * mode->vtotal);
+}
+
+static void dump_mode(drmModeModeInfo *mode, int index)
+{
+	RARCH_LOG("  #%i %s %.2f %d %d %d %d %d %d %d %d %d\n",
+	       index,
+	       mode->name,
+	       mode_vrefresh(mode),
+	       mode->hdisplay,
+	       mode->hsync_start,
+	       mode->hsync_end,
+	       mode->htotal,
+	       mode->vdisplay,
+	       mode->vsync_start,
+	       mode->vsync_end,
+	       mode->vtotal,
+	       mode->clock);
+
+	/*printf(" flags: ");
+	mode_flag_str(mode->flags);
+	printf("; type: ");
+	mode_type_str(mode->type);
+	printf("\n");*/
+}
+
 /* Load custom hdmi timings from config */
 bool gfx_ctx_drm_load_mode(drmModeModeInfoPtr modeInfo)
 {
-   int ret;
+   int ret, count=0;
    hdmi_timings_t timings;
    settings_t *settings = config_get_ptr();
    char *crt_switch_timings = settings->arrays.crt_switch_timings;
 
    if(modeInfo != NULL && !string_is_empty(crt_switch_timings)) {
-      ret = sscanf(crt_switch_timings, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
-                   &timings.h_active_pixels, &timings.h_sync_polarity, &timings.h_front_porch,
-                   &timings.h_sync_pulse, &timings.h_back_porch,
-                   &timings.v_active_lines, &timings.v_sync_polarity, &timings.v_front_porch,
-                   &timings.v_sync_pulse, &timings.v_back_porch,
-                   &timings.v_sync_offset_a, &timings.v_sync_offset_b, &timings.pixel_rep, &timings.frame_rate,
-                   &timings.interlaced, &timings.pixel_freq, &timings.aspect_ratio);
-      if (ret != 17) {
-         RARCH_ERR("[DRM]: malformed mode requested: %s\n", crt_switch_timings);
-         return false;
+      while(*crt_switch_timings) if (*crt_switch_timings++ == ' ') ++count;
+      RARCH_LOG("[CRT] found %d occurences of space in the modeline\n", count);
+      crt_switch_timings = settings->arrays.crt_switch_timings;
+      RARCH_LOG("[CRT] %s\n", crt_switch_timings);
+      if (count == 10 ) {
+         RARCH_LOG("[DRM]: got a DRM Modeline\n)");
+         ret = sscanf(crt_switch_timings, "%d %d %d %d %d %d %d %d %d %d %d",
+                      &timings.pixel_freq,
+                      &timings.h_active_pixels, &timings.h_front_porch, &timings.h_sync_pulse, &timings.h_back_porch,
+                      &timings.v_active_lines, &timings.v_front_porch, &timings.v_sync_pulse, &timings.v_back_porch,
+                      &timings.frame_rate, &timings.interlaced);
+         if (ret != 11) {
+            RARCH_ERR("[DRM]: malformed mode requested: %s\n", crt_switch_timings);
+            return false;
+         }
+         memset(modeInfo, 0, sizeof(drmModeModeInfo));
+         modeInfo->clock = timings.pixel_freq;
+         modeInfo->hdisplay = timings.h_active_pixels;
+         modeInfo->hsync_start = timings.h_front_porch;
+         modeInfo->hsync_end = timings.h_sync_pulse;
+         modeInfo->htotal = timings.h_back_porch;
+         modeInfo->hskew = 0;
+         modeInfo->vdisplay = timings.v_active_lines;
+         modeInfo->vsync_start = timings.v_front_porch;
+         modeInfo->vsync_end = timings.v_sync_pulse;
+         modeInfo->vtotal = timings.v_back_porch;
+         modeInfo->vscan = 0;
+         modeInfo->vrefresh = timings.frame_rate;
+         modeInfo->flags = timings.interlaced ? DRM_MODE_FLAG_INTERLACE : 0;
+         modeInfo->flags |= DRM_MODE_FLAG_NVSYNC;
+         modeInfo->flags |= DRM_MODE_FLAG_NHSYNC;
+         modeInfo->type = 0;
+         snprintf(modeInfo->name, DRM_DISPLAY_MODE_LEN, "CRT_%ux%u_%u",
+               modeInfo->hdisplay, modeInfo->vdisplay, modeInfo->vrefresh);
+      } else if (count == 16) {
+         ret = sscanf(crt_switch_timings, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
+                      &timings.h_active_pixels, &timings.h_sync_polarity, &timings.h_front_porch,
+                      &timings.h_sync_pulse, &timings.h_back_porch,
+                      &timings.v_active_lines, &timings.v_sync_polarity, &timings.v_front_porch,
+                      &timings.v_sync_pulse, &timings.v_back_porch,
+                      &timings.v_sync_offset_a, &timings.v_sync_offset_b, &timings.pixel_rep, &timings.frame_rate,
+                      &timings.interlaced, &timings.pixel_freq, &timings.aspect_ratio);
+         if (ret != 17) {
+            RARCH_ERR("[DRM]: malformed mode requested: %s\n", crt_switch_timings);
+            return false;
+         }
+         memset(modeInfo, 0, sizeof(drmModeModeInfo));
+         modeInfo->clock = timings.pixel_freq / 1000;
+         modeInfo->hdisplay = timings.h_active_pixels;
+         modeInfo->hsync_start = modeInfo->hdisplay + timings.h_front_porch;
+         modeInfo->hsync_end = modeInfo->hsync_start + timings.h_sync_pulse;
+         modeInfo->htotal = modeInfo->hsync_end + timings.h_back_porch;
+         modeInfo->hskew = 0;
+         modeInfo->vdisplay = timings.v_active_lines;
+         modeInfo->vsync_start = modeInfo->vdisplay + (timings.v_front_porch * (timings.interlaced ? 2 : 1));
+         modeInfo->vsync_end = modeInfo->vsync_start + (timings.v_sync_pulse * (timings.interlaced ? 2 : 1));
+         modeInfo->vtotal = modeInfo->vsync_end + (timings.v_back_porch * (timings.interlaced ? 2 : 1));
+         modeInfo->vscan = 0; /* TODO: ?? */
+         modeInfo->vrefresh = timings.frame_rate;
+         modeInfo->flags = timings.interlaced ? DRM_MODE_FLAG_INTERLACE : 0;
+         modeInfo->flags |= timings.v_sync_polarity ? DRM_MODE_FLAG_NVSYNC : DRM_MODE_FLAG_PVSYNC;
+         modeInfo->flags |= timings.h_sync_polarity ? DRM_MODE_FLAG_NHSYNC : DRM_MODE_FLAG_PHSYNC;
+         modeInfo->type = 0;
       }
 
-      memset(modeInfo, 0, sizeof(drmModeModeInfo));
-      modeInfo->clock = timings.pixel_freq / 1000;
-      modeInfo->hdisplay = timings.h_active_pixels;
-      modeInfo->hsync_start = modeInfo->hdisplay + timings.h_front_porch;
-      modeInfo->hsync_end = modeInfo->hsync_start + timings.h_sync_pulse;
-      modeInfo->htotal = modeInfo->hsync_end + timings.h_back_porch;
-      modeInfo->hskew = 0;
-      modeInfo->vdisplay = timings.v_active_lines;
-      modeInfo->vsync_start = modeInfo->vdisplay + (timings.v_front_porch * (timings.interlaced ? 2 : 1));
-      modeInfo->vsync_end = modeInfo->vsync_start + (timings.v_sync_pulse * (timings.interlaced ? 2 : 1));
-      modeInfo->vtotal = modeInfo->vsync_end + (timings.v_back_porch * (timings.interlaced ? 2 : 1));
-      modeInfo->vscan = 0; /* TODO: ?? */
-      modeInfo->vrefresh = timings.frame_rate;
-      modeInfo->flags = timings.interlaced ? DRM_MODE_FLAG_INTERLACE : 0;
-      modeInfo->flags |= timings.v_sync_polarity ? DRM_MODE_FLAG_NVSYNC : DRM_MODE_FLAG_PVSYNC;
-      modeInfo->flags |= timings.h_sync_polarity ? DRM_MODE_FLAG_NHSYNC : DRM_MODE_FLAG_PHSYNC;
-      modeInfo->type = 0;
-      snprintf(modeInfo->name, DRM_DISPLAY_MODE_LEN, "CRT_%ux%u_%u",
-               modeInfo->hdisplay, modeInfo->vdisplay, modeInfo->vrefresh);
 
+      dump_mode(modeInfo, 0);
       return true;
    }
 
@@ -167,6 +231,7 @@ static void drm_fb_destroy_callback(struct gbm_bo *bo, void *data)
 {
    struct drm_fb *fb = (struct drm_fb*)data;
 
+   RARCH_LOG("[SUBS]: destroy callback\n");
    if (fb && fb->fb_id)
       drmModeRmFB(g_drm_fd, fb->fb_id);
 
@@ -280,13 +345,16 @@ static bool gfx_ctx_drm_queue_flip(gfx_ctx_drm_data_t *drm)
    fb                = (struct drm_fb*)gbm_bo_get_user_data(drm->next_bo);
 
    if (!fb)
+   {
+      RARCH_LOG("[KMS]: gbm_bo_get_user_data returned no FB\n");
       fb             = (struct drm_fb*)drm_fb_get_from_bo(drm->next_bo);
-
+   }
    if (drmModePageFlip(g_drm_fd, g_crtc_id, fb->fb_id,
          DRM_MODE_PAGE_FLIP_EVENT, &drm->waiting_for_flip) == 0)
       return true;
 
    /* Failed to queue page flip. */
+   RARCH_LOG("[KMS]: Failed to queue page flip\n");
    return false;
 }
 
@@ -396,6 +464,7 @@ static void *gfx_ctx_drm_init(void *video_driver)
    gfx_ctx_drm_data_t *drm              = (gfx_ctx_drm_data_t*)
       calloc(1, sizeof(gfx_ctx_drm_data_t));
    unsigned video_monitor_index         = settings->uints.video_monitor_index;
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_init\n");
 
    if (!drm)
       return NULL;
@@ -489,6 +558,7 @@ error:
 static EGLint *gfx_ctx_drm_egl_fill_attribs(
       gfx_ctx_drm_data_t *drm, EGLint *attr)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_egl_fill_attribs\n");
    switch (drm_api)
    {
 #ifdef EGL_KHR_create_context
@@ -560,6 +630,7 @@ static bool gbm_choose_xrgb8888_cb(void *display_data, EGLDisplay dpy, EGLConfig
 {
    EGLint r, g, b, id;
    (void)display_data;
+   RARCH_LOG("[SUBS]: gbm_choose_xrgb8888_cb\n");
 
    /* Makes sure we have 8 bit color. */
    if (!egl_get_config_attrib(dpy, config, EGL_RED_SIZE, &r))
@@ -588,6 +659,7 @@ static bool gbm_choose_xrgb8888_cb(void *display_data, EGLDisplay dpy, EGLConfig
 
 static bool gfx_ctx_drm_egl_set_video_mode(gfx_ctx_drm_data_t *drm)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_egl_set_video_mode\n");
    const EGLint *attrib_ptr    = NULL;
    static const EGLint egl_attribs_gl[] = {
       DRM_EGL_ATTRIBS_BASE,
@@ -702,7 +774,6 @@ static bool gfx_ctx_drm_set_video_mode(void *data,
 
    if (!drm)
       return false;
-
    frontend_driver_install_signal_handler();
 
    /* If we use black frame insertion,
@@ -718,6 +789,7 @@ static bool gfx_ctx_drm_set_video_mode(void *data,
    else
    {
       /* check if custom hdmi timings were asked */
+      gfx_ctx_drm_load_mode(&gfx_ctx_crt_switch_mode);
       if(gfx_ctx_crt_switch_mode.vdisplay > 0)
       {
          RARCH_LOG("[DRM]: custom mode requested: %s\n", gfx_ctx_crt_switch_mode.name);
@@ -754,7 +826,6 @@ static bool gfx_ctx_drm_set_video_mode(void *data,
          }
       }
    }
-
    if (!g_drm_mode)
    {
       RARCH_ERR("[KMS/EGL]: Did not find suitable video mode for %u x %u.\n",
@@ -765,6 +836,15 @@ static bool gfx_ctx_drm_set_video_mode(void *data,
    drm->fb_width    = g_drm_mode->hdisplay;
    drm->fb_height   = g_drm_mode->vdisplay;
 
+   /* Don't pile up surfaces + frambuffers + egl surfaces */
+   RARCH_LOG("[GBM]: Dealing with surfaces\n");
+   if(drm->gbm_surface) {
+      RARCH_LOG("[GBM]: Destroying previous surface\n");
+      if(&drm->egl)
+         egl_destroy(&drm->egl);
+      gbm_surface_destroy(drm->gbm_surface);
+   }
+
    /* Create GBM surface. */
    drm->gbm_surface = gbm_surface_create(
          drm->gbm_dev,
@@ -868,6 +948,7 @@ static enum gfx_ctx_api gfx_ctx_drm_get_api(void *data) { return drm_api; }
 static bool gfx_ctx_drm_bind_api(void *video_driver,
       enum gfx_ctx_api api, unsigned major, unsigned minor)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_bind_api\n");
    drm_api     = api;
 #ifdef HAVE_EGL
    g_egl_major = major;
@@ -912,6 +993,7 @@ static bool gfx_ctx_drm_bind_api(void *video_driver,
 
 static void gfx_ctx_drm_bind_hw_render(void *data, bool enable)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_bind_hw_render\n");
    gfx_ctx_drm_data_t *drm     = (gfx_ctx_drm_data_t*)data;
 
 #ifdef HAVE_EGL
@@ -921,6 +1003,7 @@ static void gfx_ctx_drm_bind_hw_render(void *data, bool enable)
 
 static uint32_t gfx_ctx_drm_get_flags(void *data)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_get_flags\n");
    uint32_t             flags = 0;
    gfx_ctx_drm_data_t    *drm = (gfx_ctx_drm_data_t*)data;
 
@@ -984,4 +1067,4 @@ const gfx_ctx_driver_t gfx_ctx_drm = {
    gfx_ctx_drm_bind_hw_render,
    NULL,
    NULL
-};
+};
\ No newline at end of file
diff --git a/gfx/video_crt_switch.c b/gfx/video_crt_switch.c
index 30781beeba..2005346855 100644
--- a/gfx/video_crt_switch.c
+++ b/gfx/video_crt_switch.c
@@ -33,7 +33,7 @@
 #include "../paths.h"
 #include "gfx_display.h"
 
-#if !defined(HAVE_VIDEOCORE) 
+#if !defined(HAVE_VIDEOCORE)
 #include "../deps/switchres/switchres_wrapper.h"
 static sr_mode srm;
 #endif
@@ -57,7 +57,7 @@ static void crt_rpi_switch(videocrt_switch_t *p_switch,int width, int height, fl
 static bool crt_check_for_changes(videocrt_switch_t *p_switch)
 {
    if ((p_switch->ra_tmp_height != p_switch->ra_core_height) ||
-       (p_switch->ra_core_width != p_switch->ra_tmp_width) || 
+       (p_switch->ra_core_width != p_switch->ra_tmp_width) ||
        (p_switch->center_adjust != p_switch->tmp_center_adjust||
         p_switch->porch_adjust  != p_switch->tmp_porch_adjust ) ||
        (p_switch->ra_core_hz    != p_switch->ra_tmp_core_hz))
@@ -91,11 +91,11 @@ static void crt_aspect_ratio_switch(
          (float)p_switch->fly_aspect);
    RARCH_LOG("[CRT]: Setting Video Screen Size to: %dx%d \n",
          width, height);
-   video_driver_set_size(width , height); 
+   video_driver_set_size(width , height);
    video_driver_set_viewport(width , height,1,1);
 
    video_driver_apply_state_changes();
-   
+
 }
 
 static void set_aspect(videocrt_switch_t *p_switch,
@@ -141,26 +141,40 @@ static void set_aspect(videocrt_switch_t *p_switch,
    crt_aspect_ratio_switch(p_switch, scaled_width, scaled_height, srm_width, srm_height);
 }
 
-#if !defined(HAVE_VIDEOCORE) 
+static bool is_kms_driver_context()
+{
+   gfx_ctx_ident_t gfxctx;
+   video_context_driver_get_ident(&gfxctx);
+   RARCH_LOG("[CRT] Video context is: %s\n", gfxctx.ident);
+   if (strncmp(gfxctx.ident, "kms",3) == 0)
+      return true;
+   return false;
+}
+
+#if !defined(HAVE_VIDEOCORE)
 static bool crt_sr2_init(videocrt_switch_t *p_switch,
       int monitor_index, unsigned int crt_mode, unsigned int super_width)
 {
    const char* err_msg;
    char* mode;
    char index[10];
-  
+   int i;
+
    if (monitor_index+1 >= 0 && monitor_index+1 < 10)
       snprintf(index, sizeof(index), "%d", monitor_index);
    else
       strlcpy(index, "0", sizeof(index));
 
+   p_switch->kms_ctx = is_kms_driver_context();
+   i =  p_switch->kms_ctx ? 0 : 1;
+
    if (!p_switch->sr2_active)
    {
       sr_init();
 #if (__STDC_VERSION__ >= 199409L) /* no logs for C98 or less */
-      sr_set_log_callback_info(RARCH_LOG); 
-      sr_set_log_callback_debug(RARCH_DBG); 
-      sr_set_log_callback_error(RARCH_ERR); 
+      sr_set_log_callback_info(RARCH_LOG);
+      sr_set_log_callback_debug(RARCH_DBG);
+      sr_set_log_callback_error(RARCH_ERR);
 #endif
 
       switch (crt_mode)
@@ -190,14 +204,14 @@ static bool crt_sr2_init(videocrt_switch_t *p_switch,
       if (monitor_index+1 > 0)
       {
          RARCH_LOG("[CRT]: RA Monitor Index Manual: %s\n", &index[0]);
-         p_switch->rtn = sr_init_disp(index); 
+         p_switch->rtn = sr_init_disp(index, i);
          RARCH_LOG("[CRT]: SR Disp Monitor Index Manual: %s  \n", &index[0]);
       }
 
       if (monitor_index == -1)
       {
          RARCH_LOG("[CRT]: RA Monitor Index Auto: %s\n","auto");
-         p_switch->rtn = sr_init_disp("auto");
+         p_switch->rtn = sr_init_disp("auto", i);
          RARCH_LOG("[CRT]: SR Disp Monitor Index Auto: Auto  \n");
       }
 
@@ -209,10 +223,16 @@ static bool crt_sr2_init(videocrt_switch_t *p_switch,
          content_dir[0] = '\0';
       }
    }
-   
-   if (p_switch->rtn == 1)
+
+   if (p_switch->rtn == 1 && !p_switch->kms_ctx)
+   {
+      p_switch->sr2_active = true;
+      return true;
+   }
+   else if (p_switch->rtn == 1 && p_switch->kms_ctx)
    {
       p_switch->sr2_active = true;
+      RARCH_LOG("[CRT]: KMS context detected, keeping SR alive\n");
       return true;
    }
 
@@ -236,11 +256,14 @@ static void switch_res_crt(
    int w                   = native_width;
    int h                   = height;
    double rr               = p_switch->ra_core_hz;
+   settings_t *settings;
+   char crt_switch_timings[256];
+   char timing_backup[256];
 
    /* Check if SR2 is loaded, if not, load it */
-   if (crt_sr2_init(p_switch, monitor_index, crt_mode, super_width)) 
+   if (crt_sr2_init(p_switch, monitor_index, crt_mode, super_width))
    {
-      /* Check for core and content changes in case we need 
+      /* Check for core and content changes in case we need
          to make any adjustments */
       if (crt_switch_core_name())
          strlcpy(current_core_name, crt_switch_core_name(),
@@ -252,10 +275,10 @@ static void switch_res_crt(
             path_get(RARCH_PATH_CONTENT),
             sizeof(current_content_dir));
 
-      if (     !string_is_equal(core_name,   current_core_name) 
+      if (     !string_is_equal(core_name,   current_core_name)
             || !string_is_equal(content_dir, current_content_dir))
       {
-         /* A core or content change was detected, 
+         /* A core or content change was detected,
             we update the current values and make adjustments */
          strlcpy(core_name, current_core_name, sizeof(core_name));
          strlcpy(content_dir, current_content_dir, sizeof(content_dir));
@@ -264,7 +287,34 @@ static void switch_res_crt(
          crt_check_hh_core(p_switch);
       }
 
-      if (!(ret = sr_switch_to_mode(w, h, rr, interlace, &srm)))
+      if (p_switch->kms_ctx)
+      {
+         RARCH_LOG("[CRT]: KMS -> use sr_add_mode\n");
+         ret =   sr_add_mode(w, h, rr, interlace, &srm);
+         printf("Modeline is: %ld %d %d %d %d %d %d %d %d %f\n", srm.modeline.pclock,
+            srm.modeline.hactive, srm.modeline.hbegin, srm.modeline.hend, srm.modeline.htotal,
+            srm.modeline.vactive, srm.modeline.vbegin, srm.modeline.vend, srm.modeline.vtotal,
+            srm.modeline.vfreq);
+         settings_t *settings = config_get_ptr();
+
+         strcpy(timing_backup, settings->arrays.crt_switch_timings);
+         /* DRM modeline */
+         ret = sprintf(crt_switch_timings, "%ld %d %d %d %d %d %d %d %d %d %d",
+                   srm.modeline.pclock/1000,
+                   srm.modeline.hactive, srm.modeline.hbegin, srm.modeline.hend, srm.modeline.htotal,
+                   srm.modeline.vactive, srm.modeline.vbegin, srm.modeline.vend, srm.modeline.vtotal,
+                   (int)srm.modeline.vfreq, srm.interlace);
+         strcpy(settings->arrays.crt_switch_timings, crt_switch_timings);
+         crt_switch_driver_refresh();
+         //video_driver_set_video_mode(srm.width, srm.height, true);
+         strcpy(settings->arrays.crt_switch_timings, timing_backup);
+      } else {
+         ret =   sr_switch_to_mode(w, h, rr, interlace, &srm);
+      }
+
+      if(!p_switch->kms_ctx && !p_switch->kms_ctx)
+
+      if (!p_switch->kms_ctx && !(ret = sr_switch_to_mode(w, h, rr, interlace, &srm)))
          RARCH_LOG("[CRT]: SR failed to switch mode");
       p_switch->sr_core_hz = srm.refresh;
 
@@ -275,7 +325,7 @@ static void switch_res_crt(
    {
       set_aspect(p_switch, width , height, width, height,
             (float)1, (float)1, false);
-      video_driver_set_size(width , height); 
+      video_driver_set_size(width , height);
       video_driver_apply_state_changes();
    }
 }
@@ -293,9 +343,9 @@ void crt_destroy_modes(videocrt_switch_t *p_switch)
 static void crt_check_hh_core(videocrt_switch_t *p_switch)
 {
    p_switch->hh_core = false;
-} 
+}
 
-#if !defined(HAVE_VIDEOCORE) 
+#if !defined(HAVE_VIDEOCORE)
 static void crt_fix_hh_res(videocrt_switch_t *p_switch,
       int native_width, int width,  int height,
       int crt_mode, int monitor_index, int super_width)
@@ -378,7 +428,7 @@ void crt_switch_res_core(
       }
 
    }
-   
+
 }
 
 void crt_adjust_sr_ini(videocrt_switch_t *p_switch)
@@ -388,8 +438,8 @@ void crt_adjust_sr_ini(videocrt_switch_t *p_switch)
 
    if (p_switch->sr2_active)
    {
-      /* First we reload the base switchres.ini file 
-         to undo any overrides that might have been 
+      /* First we reload the base switchres.ini file
+         to undo any overrides that might have been
          loaded for another core */
       if (ini_overrides_loaded)
       {
@@ -400,7 +450,7 @@ void crt_adjust_sr_ini(videocrt_switch_t *p_switch)
 
       if (strlen(core_name) > 0)
       {
-         /* Then we look for config/Core Name/Core Name.switchres.ini 
+         /* Then we look for config/Core Name/Core Name.switchres.ini
             and load it, overriding any variables it specifies */
          config_directory[0] = '\0';
          fill_pathname_application_special(config_directory,
@@ -471,21 +521,21 @@ static void crt_rpi_switch(videocrt_switch_t *p_switch,
    /* set core refresh from hz */
    video_monitor_set_refresh_rate(hz);
 
-   set_aspect(p_switch, width, 
+   set_aspect(p_switch, width,
       height, width, height,
       (float)1, (float)1, false);
 
    w = width;
-   while (w < 1920) 
+   while (w < 1920)
       w = w+width;
-   
+
    if (w > 2000)
          w =w- width;
-   
+
    width = w;
 
    crt_aspect_ratio_switch(p_switch, width,height,width,height);
-   
+
    /* following code is the mode line generator */
    hfp      = ((width * 0.044) + (width / 112));
    hbp      = ((width * 0.172) + (width /64));
diff --git a/gfx/video_crt_switch.h b/gfx/video_crt_switch.h
index da2bf60228..06eb4757f4 100644
--- a/gfx/video_crt_switch.h
+++ b/gfx/video_crt_switch.h
@@ -55,7 +55,7 @@ typedef struct videocrt_switch
    bool sr2_active;
    bool menu_active;
    bool hh_core;
-
+   bool kms_ctx;
 
 } videocrt_switch_t;
 
diff --git a/gfx/video_driver.c b/gfx/video_driver.c
index c5f974a4ce..fca953f2c7 100644
--- a/gfx/video_driver.c
+++ b/gfx/video_driver.c
@@ -42,15 +42,15 @@
 
 #ifdef HAVE_MENU
 #include "../menu/menu_driver.h"
-#endif
-
-#ifdef _WIN32
-#include "common/win32_common.h"
+#endif
+
+#ifdef _WIN32
+#include "common/win32_common.h"
 #endif
 
 #include "../audio/audio_driver.h"
 #include "../frontend/frontend_driver.h"
-#include "../record/record_driver.h"
+#include "../record/record_driver.h"
 #include "../ui/ui_companion_driver.h"
 #include "../driver.h"
 #include "../file_path_special.h"
@@ -276,9 +276,9 @@ const video_driver_t *video_drivers[] = {
 #ifdef HAVE_OPENGL
    &video_gl2,
 #endif
-#if defined(HAVE_OPENGL_CORE)
-   &video_gl3,
-#endif
+#if defined(HAVE_OPENGL_CORE)
+   &video_gl3,
+#endif
 #ifdef HAVE_OPENGL1
    &video_gl1,
 #endif
@@ -389,7 +389,7 @@ const video_driver_t *video_drivers[] = {
 };
 
 static video_driver_state_t video_driver_st = { 0 };
-static const video_display_server_t *current_display_server = 
+static const video_display_server_t *current_display_server =
 &dispserv_null;
 
 struct retro_hw_render_callback *video_driver_get_hw_context(void)
@@ -402,12 +402,12 @@ video_driver_state_t *video_state_get_ptr(void)
 {
    return &video_driver_st;
 }
-
-void crt_switch_driver_refresh(void)
-{
-   video_driver_reinit(DRIVERS_CMD_ALL);
-}
-
+
+void crt_switch_driver_refresh(void)
+{
+   video_driver_reinit(DRIVER_VIDEO_MASK);
+}
+
 
 #ifdef HAVE_THREADS
 void *video_thread_get_ptr(video_driver_state_t *video_st)
@@ -440,11 +440,11 @@ video_driver_t *hw_render_context_driver(
    switch (type)
    {
       case RETRO_HW_CONTEXT_OPENGL_CORE:
-#ifdef HAVE_OPENGL_CORE
-         return &video_gl3;
-#else
-         break;
-#endif
+#ifdef HAVE_OPENGL_CORE
+         return &video_gl3;
+#else
+         break;
+#endif
       case RETRO_HW_CONTEXT_OPENGL:
 #ifdef HAVE_OPENGL
          return &video_gl2;
@@ -733,7 +733,7 @@ void video_context_driver_destroy(gfx_ctx_driver_t *ctx_driver)
    ctx_driver->get_video_output_size      = NULL;
    ctx_driver->get_video_output_prev      = NULL;
    ctx_driver->get_video_output_next      = NULL;
-   ctx_driver->get_metrics                = 
+   ctx_driver->get_metrics                =
       video_context_driver_get_metrics_null;
    ctx_driver->translate_aspect           = NULL;
    ctx_driver->update_window_title        = NULL;
@@ -931,9 +931,9 @@ void recording_dump_frame(
       unsigned height, size_t pitch, bool is_idle)
 {
    struct record_video_data ffemu_data;
-   video_driver_state_t 
+   video_driver_state_t
 	   *video_st   = &video_driver_st;
-   recording_state_t 
+   recording_state_t
       *record_st       = recording_state_get_ptr();
 
    ffemu_data.data     = data;
@@ -1675,7 +1675,7 @@ void *video_driver_read_frame_raw(unsigned *width,
    unsigned *height, size_t *pitch)
 {
    video_driver_state_t *video_st = &video_driver_st;
-   if (      video_st->current_video 
+   if (      video_st->current_video
          &&  video_st->current_video->read_frame_raw)
       return video_st->current_video->read_frame_raw(
             video_st->data, width,
@@ -1687,7 +1687,7 @@ void video_driver_set_filtering(unsigned index,
       bool smooth, bool ctx_scaling)
 {
    video_driver_state_t *video_st = &video_driver_st;
-   if (     video_st->poke 
+   if (     video_st->poke
          && video_st->poke->set_filtering)
       video_st->poke->set_filtering(
             video_st->data,
@@ -1697,7 +1697,7 @@ void video_driver_set_filtering(unsigned index,
 void video_driver_set_hdr_max_nits(float max_nits)
 {
    video_driver_state_t *video_st = &video_driver_st;
-   if (     video_st->poke 
+   if (     video_st->poke
          && video_st->poke->set_hdr_max_nits)
       video_st->poke->set_hdr_max_nits(video_st->data, max_nits);
 }
@@ -1705,7 +1705,7 @@ void video_driver_set_hdr_max_nits(float max_nits)
 void video_driver_set_hdr_paper_white_nits(float paper_white_nits)
 {
    video_driver_state_t *video_st = &video_driver_st;
-   if (     video_st->poke 
+   if (     video_st->poke
          && video_st->poke->set_hdr_paper_white_nits)
       video_st->poke->set_hdr_paper_white_nits(video_st->data, paper_white_nits);
 }
@@ -1713,7 +1713,7 @@ void video_driver_set_hdr_paper_white_nits(float paper_white_nits)
 void video_driver_set_hdr_contrast(float contrast)
 {
    video_driver_state_t *video_st = &video_driver_st;
-   if (     video_st->poke 
+   if (     video_st->poke
          && video_st->poke->set_hdr_contrast)
       video_st->poke->set_hdr_contrast(video_st->data,
             VIDEO_HDR_MAX_CONTRAST - contrast);
@@ -1722,27 +1722,27 @@ void video_driver_set_hdr_contrast(float contrast)
 void video_driver_set_hdr_expand_gamut(bool expand_gamut)
 {
    video_driver_state_t *video_st = &video_driver_st;
-   if (     video_st->poke 
+   if (     video_st->poke
          && video_st->poke->set_hdr_expand_gamut)
       video_st->poke->set_hdr_expand_gamut(video_st->data, expand_gamut);
 }
 
-/* Use this value as a replacement for anywhere 
- * where a pure white colour value is used in the UI.  
+/* Use this value as a replacement for anywhere
+ * where a pure white colour value is used in the UI.
  *
- * When HDR is turned on 1,1,1,1 should never really 
- * be used as this is peak brightness and could cause 
- * damage to displays over long periods of time 
- * and be quite hard to look at on really bright displays.  
+ * When HDR is turned on 1,1,1,1 should never really
+ * be used as this is peak brightness and could cause
+ * damage to displays over long periods of time
+ * and be quite hard to look at on really bright displays.
  *
- * Use paper white instead which is always defined as 
- * 0.5, 0.5, 0.5, 1.0 or in other words is the top of 
+ * Use paper white instead which is always defined as
+ * 0.5, 0.5, 0.5, 1.0 or in other words is the top of
  * the old SDR (Standard Dynamic Range) range
  */
 unsigned video_driver_get_hdr_paper_white(void)
 {
    /* 0.5, 0.5, 0.5, 1 */
-   if (     video_driver_supports_hdr() 
+   if (     video_driver_supports_hdr()
          && config_get_ptr()->bools.video_hdr_enable)
       return 0x7f7f7fff;
    return 0xffffffff;
@@ -1753,36 +1753,36 @@ float *video_driver_get_hdr_paper_white_float(void)
 {
    static float paper_white[4] = { 0.5f, 0.5f, 0.5f, 1.0f};
    static float sdr_white  [4] = { 1.0f, 1.0f, 1.0f, 1.0f};
-   if(      video_driver_supports_hdr() 
+   if(      video_driver_supports_hdr()
          && config_get_ptr()->bools.video_hdr_enable)
       return paper_white;
    return sdr_white;
 }
 
-/* This is useful to create a HDR (High Dynamic Range) white 
- * based off of some passed in nit level - say you want a 
- * slightly brighter than paper white value for some parts 
- * of the UI 
+/* This is useful to create a HDR (High Dynamic Range) white
+ * based off of some passed in nit level - say you want a
+ * slightly brighter than paper white value for some parts
+ * of the UI
  */
 float video_driver_get_hdr_luminance(float nits)
 {
    settings_t *settings                = config_get_ptr();
    if(video_driver_supports_hdr() && settings->bools.video_hdr_enable)
    {
-      float luminance = nits / 
+      float luminance = nits /
          settings->floats.video_hdr_paper_white_nits;
       return luminance / (1.0f + luminance);
    }
    return nits;
 }
 
-/* Get reinhard tone mapped colour value for UI elements 
- * when using HDR and its inverse tonemapper - normally don't use 
- * but useful if you want a specific colour to look the same 
+/* Get reinhard tone mapped colour value for UI elements
+ * when using HDR and its inverse tonemapper - normally don't use
+ * but useful if you want a specific colour to look the same
  * after inverse tonemapping has been applied */
 unsigned video_driver_get_hdr_color(unsigned color)
 {
-   if(   video_driver_supports_hdr() 
+   if(   video_driver_supports_hdr()
       && config_get_ptr()->bools.video_hdr_enable)
    {
       float luminance;
@@ -1801,9 +1801,9 @@ unsigned video_driver_get_hdr_color(unsigned color)
 
       convert_yxy_to_rgb(rgb, yxy);
 
-      return (    (unsigned)(saturate_value(rgb[0]) * 255.0f) << 24) 
-              |  ((unsigned)(saturate_value(rgb[1]) * 255.0f) << 16) 
-              |  ((unsigned)(saturate_value(rgb[2]) * 255.0f) << 8) 
+      return (    (unsigned)(saturate_value(rgb[0]) * 255.0f) << 24)
+              |  ((unsigned)(saturate_value(rgb[1]) * 255.0f) << 16)
+              |  ((unsigned)(saturate_value(rgb[2]) * 255.0f) << 8)
               |   (color & 0xFF);
    }
    return color;
@@ -2236,7 +2236,7 @@ void video_driver_update_viewport(
 void video_driver_show_mouse(void)
 {
    video_driver_state_t *video_st = &video_driver_st;
-   if (     video_st->poke 
+   if (     video_st->poke
          && video_st->poke->show_mouse)
       video_st->poke->show_mouse(video_st->data, true);
 }
@@ -2244,7 +2244,7 @@ void video_driver_show_mouse(void)
 void video_driver_hide_mouse(void)
 {
    video_driver_state_t *video_st = &video_driver_st;
-   if (     video_st->poke 
+   if (     video_st->poke
          && video_st->poke->show_mouse)
       video_st->poke->show_mouse(video_st->data, false);
 }
@@ -2644,7 +2644,7 @@ void video_driver_cached_frame(void)
    if (runloop_st->current_core.inited)
       cbs->frame_cb(
             (video_st->frame_cache_data != RETRO_HW_FRAME_BUFFER_VALID)
-            ? video_st->frame_cache_data 
+            ? video_st->frame_cache_data
             : NULL,
             video_st->frame_cache_width,
             video_st->frame_cache_height,
@@ -3577,7 +3577,7 @@ void video_driver_frame(const void *data, unsigned width,
 #if defined(HAVE_GFX_WIDGETS)
    bool widgets_active           = dispwidget_get_ptr()->active;
 #endif
-   recording_state_t 
+   recording_state_t
       *recording_st              = recording_state_get_ptr();
 
    status_text[0]                = '\0';
