diff --git a/Makefile.common b/Makefile.common
index bc377dca9a..acf7e5c914 100644
--- a/Makefile.common
+++ b/Makefile.common
@@ -2326,6 +2326,8 @@ ifeq ($(HAVE_CRTSWITCHRES), 1)
          OBJ += $(DEPS_DIR)/switchres/custom_video_xrandr.o
          DEFINES += -DSR_WITH_XRANDR
       endif
+#      OBJ += $(DEPS_DIR)/switchres/custom_video_drmkms.o
+#      DEFINES += -DSR_WITH_KMSDRM
    endif
    ifneq ($(findstring Win32,$(OS)),)
       DEFINES += -DSR_WIN32_STATIC
diff --git a/deps/switchres/switchres_wrapper.cpp b/deps/switchres/switchres_wrapper.cpp
index d92c55bc7c..57012131af 100644
--- a/deps/switchres/switchres_wrapper.cpp
+++ b/deps/switchres/switchres_wrapper.cpp
@@ -16,6 +16,7 @@
 #include "switchres.h"
 #include "switchres_wrapper.h"
 #include "log.h"
+#include "modeline.h"
 #include <stdio.h>
 #include <locale>
 #ifdef __cplusplus
@@ -39,11 +40,11 @@ MODULE_API void sr_load_ini(char* config) {
 }
 
 
-MODULE_API unsigned char sr_init_disp(const char* scr) {
+MODULE_API unsigned char sr_init_disp(const char* scr, int i) {
 	if (scr)
 		swr->set_screen(scr);
 	swr->add_display();
-	if (!swr->display()->init())
+	if (i > 0 && !swr->display()->init())
 		return 0;
 	return 1;
 }
@@ -68,8 +69,25 @@ MODULE_API void sr_set_user_mode(int width, int height, int refresh) {
 }
 
 
+void best_mode_to_sr_modeline(display_manager* disp, sr_modeline* modeline)
+{
+	modeline->pclock  = disp->best_mode()->pclock;
+	modeline->hactive = disp->best_mode()->hactive;
+	modeline->hbegin  = disp->best_mode()->hbegin;
+	modeline->hend    = disp->best_mode()->hend;
+	modeline->htotal  = disp->best_mode()->htotal;
+	modeline->vactive = disp->best_mode()->vactive;
+	modeline->vbegin  = disp->best_mode()->vbegin;
+	modeline->vend    = disp->best_mode()->vend;
+	modeline->vtotal  = disp->best_mode()->vtotal;
+	modeline->vfreq   = disp->best_mode()->vfreq;
+	modeline->type    = disp->best_mode()->type;
+}
+
+
 void disp_best_mode_to_sr_mode(display_manager* disp, sr_mode* srm)
 {
+	sr_modeline* srml = &(srm->modeline);
 	srm->width = disp->width();
 	srm->height = disp->height();
 	srm->refresh = disp->v_freq();
@@ -78,6 +96,7 @@ void disp_best_mode_to_sr_mode(display_manager* disp, sr_mode* srm)
 	srm->x_scale = disp->x_scale();
 	srm->y_scale = disp->y_scale();
 	srm->interlace = (disp->is_interlaced() ? 105 : 0);
+	best_mode_to_sr_modeline(disp, &(srm->modeline));
 }
 
 
diff --git a/deps/switchres/switchres_wrapper.h b/deps/switchres/switchres_wrapper.h
index c31da657b9..38f671f88e 100644
--- a/deps/switchres/switchres_wrapper.h
+++ b/deps/switchres/switchres_wrapper.h
@@ -75,6 +75,24 @@ char* LIBERROR()
 #endif
 
 /* That's all the exposed data from Switchres calculation */
+typedef struct MODULE_API
+{
+	uint64_t    pclock;
+	int    hactive;
+	int    hbegin;
+	int    hend;
+	int    htotal;
+	int    vactive;
+	int    vbegin;
+	int    vend;
+	int    vtotal;
+	//
+	double vfreq;
+	//
+	int    type;
+	//
+} sr_modeline;
+
 typedef struct MODULE_API {
 	int width;
 	int height;
@@ -84,6 +102,7 @@ typedef struct MODULE_API {
 	int x_scale;
 	int y_scale;
 	unsigned char interlace;
+	sr_modeline modeline;
 } sr_mode;
 
 
@@ -91,7 +110,7 @@ typedef struct MODULE_API {
 MODULE_API void sr_init();
 MODULE_API void sr_load_ini(char* config);
 MODULE_API void sr_deinit();
-MODULE_API unsigned char sr_init_disp(const char* src);
+MODULE_API unsigned char sr_init_disp(const char* src, int i);
 MODULE_API unsigned char sr_add_mode(int, int, double, unsigned char, sr_mode*);
 MODULE_API unsigned char sr_switch_to_mode(int, int, double, unsigned char, sr_mode*);
 MODULE_API void sr_set_monitor(const char*);
@@ -110,7 +129,7 @@ typedef struct MODULE_API {
     void (*init)(void);
     void (*sr_sr_load_ini)(char*);
     void (*deinit)(void);
-    unsigned char (*sr_init_disp)(const char*);
+    unsigned char (*sr_init_disp)(const char*, int);
     unsigned char (*sr_add_mode)(int, int, double, unsigned char, sr_mode*);
     unsigned char (*sr_switch_to_mode)(int, int, double, unsigned char, sr_mode*);
     void (*sr_set_monitor)(const char*);
diff --git a/gfx/drivers_context/drm_ctx.c b/gfx/drivers_context/drm_ctx.c
index eeaa4a2687..995ab9d8cd 100644
--- a/gfx/drivers_context/drm_ctx.c
+++ b/gfx/drivers_context/drm_ctx.c
@@ -115,47 +115,111 @@ typedef struct hdmi_timings
 static enum gfx_ctx_api drm_api           = GFX_CTX_NONE;
 static drmModeModeInfo gfx_ctx_crt_switch_mode;
 
+static float mode_vrefresh(drmModeModeInfo *mode)
+{
+	return  mode->clock * 1000.00
+			/ (mode->htotal * mode->vtotal);
+}
+
+static void dump_mode(drmModeModeInfo *mode, int index)
+{
+	RARCH_LOG("  #%i %s %.2f %d %d %d %d %d %d %d %d %d\n",
+	       index,
+	       mode->name,
+	       mode_vrefresh(mode),
+	       mode->hdisplay,
+	       mode->hsync_start,
+	       mode->hsync_end,
+	       mode->htotal,
+	       mode->vdisplay,
+	       mode->vsync_start,
+	       mode->vsync_end,
+	       mode->vtotal,
+	       mode->clock);
+
+	/*printf(" flags: ");
+	mode_flag_str(mode->flags);
+	printf("; type: ");
+	mode_type_str(mode->type);
+	printf("\n");*/
+}
+
 /* Load custom hdmi timings from config */
 bool gfx_ctx_drm_load_mode(drmModeModeInfoPtr modeInfo)
 {
-   int ret;
+   int ret, count=0;
    hdmi_timings_t timings;
    settings_t *settings = config_get_ptr();
    char *crt_switch_timings = settings->arrays.crt_switch_timings;
 
    if(modeInfo != NULL && !string_is_empty(crt_switch_timings)) {
-      ret = sscanf(crt_switch_timings, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
-                   &timings.h_active_pixels, &timings.h_sync_polarity, &timings.h_front_porch,
-                   &timings.h_sync_pulse, &timings.h_back_porch,
-                   &timings.v_active_lines, &timings.v_sync_polarity, &timings.v_front_porch,
-                   &timings.v_sync_pulse, &timings.v_back_porch,
-                   &timings.v_sync_offset_a, &timings.v_sync_offset_b, &timings.pixel_rep, &timings.frame_rate,
-                   &timings.interlaced, &timings.pixel_freq, &timings.aspect_ratio);
-      if (ret != 17) {
-         RARCH_ERR("[DRM]: malformed mode requested: %s\n", crt_switch_timings);
-         return false;
+      while(*crt_switch_timings) if (*crt_switch_timings++ == ' ') ++count;
+      RARCH_LOG("[CRT] found %d occurences of space in the modeline\n", count);
+      crt_switch_timings = settings->arrays.crt_switch_timings;
+      RARCH_LOG("[CRT] %s\n", crt_switch_timings);
+      if (count == 10 ) {
+         RARCH_LOG("[DRM]: got a DRM Modeline\n)");
+         ret = sscanf(crt_switch_timings, "%d %d %d %d %d %d %d %d %d %d %d",
+                      &timings.pixel_freq,
+                      &timings.h_active_pixels, &timings.h_front_porch, &timings.h_sync_pulse, &timings.h_back_porch,
+                      &timings.v_active_lines, &timings.v_front_porch, &timings.v_sync_pulse, &timings.v_back_porch,
+                      &timings.frame_rate, &timings.interlaced);
+         if (ret != 11) {
+            RARCH_ERR("[DRM]: malformed mode requested: %s\n", crt_switch_timings);
+            return false;
+         }
+         memset(modeInfo, 0, sizeof(drmModeModeInfo));
+         modeInfo->clock = timings.pixel_freq;
+         modeInfo->hdisplay = timings.h_active_pixels;
+         modeInfo->hsync_start = timings.h_front_porch;
+         modeInfo->hsync_end = timings.h_sync_pulse;
+         modeInfo->htotal = timings.h_back_porch;
+         modeInfo->hskew = 0;
+         modeInfo->vdisplay = timings.v_active_lines;
+         modeInfo->vsync_start = timings.v_front_porch;
+         modeInfo->vsync_end = timings.v_sync_pulse;
+         modeInfo->vtotal = timings.v_back_porch;
+         modeInfo->vscan = 0;
+         modeInfo->vrefresh = timings.frame_rate;
+         modeInfo->flags = timings.interlaced ? DRM_MODE_FLAG_INTERLACE : 0;
+         modeInfo->flags |= DRM_MODE_FLAG_NVSYNC;
+         modeInfo->flags |= DRM_MODE_FLAG_NHSYNC;
+         modeInfo->type = 0;
+         snprintf(modeInfo->name, DRM_DISPLAY_MODE_LEN, "CRT_%ux%u_%u",
+               modeInfo->hdisplay, modeInfo->vdisplay, modeInfo->vrefresh);
+      } else if (count == 16) {
+         ret = sscanf(crt_switch_timings, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d",
+                      &timings.h_active_pixels, &timings.h_sync_polarity, &timings.h_front_porch,
+                      &timings.h_sync_pulse, &timings.h_back_porch,
+                      &timings.v_active_lines, &timings.v_sync_polarity, &timings.v_front_porch,
+                      &timings.v_sync_pulse, &timings.v_back_porch,
+                      &timings.v_sync_offset_a, &timings.v_sync_offset_b, &timings.pixel_rep, &timings.frame_rate,
+                      &timings.interlaced, &timings.pixel_freq, &timings.aspect_ratio);
+         if (ret != 17) {
+            RARCH_ERR("[DRM]: malformed mode requested: %s\n", crt_switch_timings);
+            return false;
+         }
+         memset(modeInfo, 0, sizeof(drmModeModeInfo));
+         modeInfo->clock = timings.pixel_freq / 1000;
+         modeInfo->hdisplay = timings.h_active_pixels;
+         modeInfo->hsync_start = modeInfo->hdisplay + timings.h_front_porch;
+         modeInfo->hsync_end = modeInfo->hsync_start + timings.h_sync_pulse;
+         modeInfo->htotal = modeInfo->hsync_end + timings.h_back_porch;
+         modeInfo->hskew = 0;
+         modeInfo->vdisplay = timings.v_active_lines;
+         modeInfo->vsync_start = modeInfo->vdisplay + (timings.v_front_porch * (timings.interlaced ? 2 : 1));
+         modeInfo->vsync_end = modeInfo->vsync_start + (timings.v_sync_pulse * (timings.interlaced ? 2 : 1));
+         modeInfo->vtotal = modeInfo->vsync_end + (timings.v_back_porch * (timings.interlaced ? 2 : 1));
+         modeInfo->vscan = 0; /* TODO: ?? */
+         modeInfo->vrefresh = timings.frame_rate;
+         modeInfo->flags = timings.interlaced ? DRM_MODE_FLAG_INTERLACE : 0;
+         modeInfo->flags |= timings.v_sync_polarity ? DRM_MODE_FLAG_NVSYNC : DRM_MODE_FLAG_PVSYNC;
+         modeInfo->flags |= timings.h_sync_polarity ? DRM_MODE_FLAG_NHSYNC : DRM_MODE_FLAG_PHSYNC;
+         modeInfo->type = 0;
       }
 
-      memset(modeInfo, 0, sizeof(drmModeModeInfo));
-      modeInfo->clock = timings.pixel_freq / 1000;
-      modeInfo->hdisplay = timings.h_active_pixels;
-      modeInfo->hsync_start = modeInfo->hdisplay + timings.h_front_porch;
-      modeInfo->hsync_end = modeInfo->hsync_start + timings.h_sync_pulse;
-      modeInfo->htotal = modeInfo->hsync_end + timings.h_back_porch;
-      modeInfo->hskew = 0;
-      modeInfo->vdisplay = timings.v_active_lines;
-      modeInfo->vsync_start = modeInfo->vdisplay + (timings.v_front_porch * (timings.interlaced ? 2 : 1));
-      modeInfo->vsync_end = modeInfo->vsync_start + (timings.v_sync_pulse * (timings.interlaced ? 2 : 1));
-      modeInfo->vtotal = modeInfo->vsync_end + (timings.v_back_porch * (timings.interlaced ? 2 : 1));
-      modeInfo->vscan = 0; /* TODO: ?? */
-      modeInfo->vrefresh = timings.frame_rate;
-      modeInfo->flags = timings.interlaced ? DRM_MODE_FLAG_INTERLACE : 0;
-      modeInfo->flags |= timings.v_sync_polarity ? DRM_MODE_FLAG_NVSYNC : DRM_MODE_FLAG_PVSYNC;
-      modeInfo->flags |= timings.h_sync_polarity ? DRM_MODE_FLAG_NHSYNC : DRM_MODE_FLAG_PHSYNC;
-      modeInfo->type = 0;
-      snprintf(modeInfo->name, DRM_DISPLAY_MODE_LEN, "CRT_%ux%u_%u",
-               modeInfo->hdisplay, modeInfo->vdisplay, modeInfo->vrefresh);
 
+      dump_mode(modeInfo, 0);
       return true;
    }
 
@@ -166,6 +230,7 @@ static void drm_fb_destroy_callback(struct gbm_bo *bo, void *data)
 {
    struct drm_fb *fb = (struct drm_fb*)data;
 
+   RARCH_LOG("[SUBS]: destroy callback\n");
    if (fb && fb->fb_id)
       drmModeRmFB(g_drm_fd, fb->fb_id);
 
@@ -279,13 +344,16 @@ static bool gfx_ctx_drm_queue_flip(gfx_ctx_drm_data_t *drm)
    fb                = (struct drm_fb*)gbm_bo_get_user_data(drm->next_bo);
 
    if (!fb)
+   {
+      RARCH_LOG("[KMS]: gbm_bo_get_user_data returned no FB\n");
       fb             = (struct drm_fb*)drm_fb_get_from_bo(drm->next_bo);
-
+   }
    if (drmModePageFlip(g_drm_fd, g_crtc_id, fb->fb_id,
          DRM_MODE_PAGE_FLIP_EVENT, &drm->waiting_for_flip) == 0)
       return true;
 
    /* Failed to queue page flip. */
+   RARCH_LOG("[KMS]: Failed to queue page flip\n");
    return false;
 }
 
@@ -395,6 +463,7 @@ static void *gfx_ctx_drm_init(void *video_driver)
    gfx_ctx_drm_data_t *drm              = (gfx_ctx_drm_data_t*)
       calloc(1, sizeof(gfx_ctx_drm_data_t));
    unsigned video_monitor_index         = settings->uints.video_monitor_index;
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_init\n");
 
    if (!drm)
       return NULL;
@@ -488,6 +557,7 @@ error:
 static EGLint *gfx_ctx_drm_egl_fill_attribs(
       gfx_ctx_drm_data_t *drm, EGLint *attr)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_egl_fill_attribs\n");
    switch (drm_api)
    {
 #ifdef EGL_KHR_create_context
@@ -559,6 +629,7 @@ static bool gbm_choose_xrgb8888_cb(void *display_data, EGLDisplay dpy, EGLConfig
 {
    EGLint r, g, b, id;
    (void)display_data;
+   RARCH_LOG("[SUBS]: gbm_choose_xrgb8888_cb\n");
 
    /* Makes sure we have 8 bit color. */
    if (!egl_get_config_attrib(dpy, config, EGL_RED_SIZE, &r))
@@ -587,6 +658,7 @@ static bool gbm_choose_xrgb8888_cb(void *display_data, EGLDisplay dpy, EGLConfig
 
 static bool gfx_ctx_drm_egl_set_video_mode(gfx_ctx_drm_data_t *drm)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_egl_set_video_mode\n");
    const EGLint *attrib_ptr    = NULL;
    static const EGLint egl_attribs_gl[] = {
       DRM_EGL_ATTRIBS_BASE,
@@ -701,7 +773,6 @@ static bool gfx_ctx_drm_set_video_mode(void *data,
 
    if (!drm)
       return false;
-
    frontend_driver_install_signal_handler();
 
    /* If we use black frame insertion,
@@ -717,6 +788,7 @@ static bool gfx_ctx_drm_set_video_mode(void *data,
    else
    {
       /* check if custom hdmi timings were asked */
+      gfx_ctx_drm_load_mode(&gfx_ctx_crt_switch_mode);
       if(gfx_ctx_crt_switch_mode.vdisplay > 0)
       {
          RARCH_LOG("[DRM]: custom mode requested: %s\n", gfx_ctx_crt_switch_mode.name);
@@ -753,7 +825,6 @@ static bool gfx_ctx_drm_set_video_mode(void *data,
          }
       }
    }
-
    if (!g_drm_mode)
    {
       RARCH_ERR("[KMS/EGL]: Did not find suitable video mode for %u x %u.\n",
@@ -764,6 +835,15 @@ static bool gfx_ctx_drm_set_video_mode(void *data,
    drm->fb_width    = g_drm_mode->hdisplay;
    drm->fb_height   = g_drm_mode->vdisplay;
 
+   /* Don't pile up surfaces + frambuffers + egl surfaces */
+   RARCH_LOG("[GBM]: Dealing with surfaces\n");
+   if(drm->gbm_surface) {
+      RARCH_LOG("[GBM]: Destroying previous surface\n");
+      if(&drm->egl)
+         egl_destroy(&drm->egl);
+      gbm_surface_destroy(drm->gbm_surface);
+   }
+
    /* Create GBM surface. */
    drm->gbm_surface = gbm_surface_create(
          drm->gbm_dev,
@@ -867,6 +947,7 @@ static enum gfx_ctx_api gfx_ctx_drm_get_api(void *data) { return drm_api; }
 static bool gfx_ctx_drm_bind_api(void *video_driver,
       enum gfx_ctx_api api, unsigned major, unsigned minor)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_bind_api\n");
    drm_api     = api;
 #ifdef HAVE_EGL
    g_egl_major = major;
@@ -911,6 +992,7 @@ static bool gfx_ctx_drm_bind_api(void *video_driver,
 
 static void gfx_ctx_drm_bind_hw_render(void *data, bool enable)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_bind_hw_render\n");
    gfx_ctx_drm_data_t *drm     = (gfx_ctx_drm_data_t*)data;
 
 #ifdef HAVE_EGL
@@ -920,6 +1002,7 @@ static void gfx_ctx_drm_bind_hw_render(void *data, bool enable)
 
 static uint32_t gfx_ctx_drm_get_flags(void *data)
 {
+   RARCH_LOG("[SUBS]: gfx_ctx_drm_get_flags\n");
    uint32_t             flags = 0;
    gfx_ctx_drm_data_t    *drm = (gfx_ctx_drm_data_t*)data;
 
@@ -983,4 +1066,4 @@ const gfx_ctx_driver_t gfx_ctx_drm = {
    gfx_ctx_drm_bind_hw_render,
    NULL,
    NULL
-};
+};
\ No newline at end of file
diff --git a/gfx/video_crt_switch.c b/gfx/video_crt_switch.c
index 4a7a6bbdca..6ad785e8c8 100644
--- a/gfx/video_crt_switch.c
+++ b/gfx/video_crt_switch.c
@@ -33,7 +33,7 @@
 #include "../paths.h"
 #include "gfx_display.h"
 
-#if !defined(HAVE_VIDEOCORE) 
+#if !defined(HAVE_VIDEOCORE)
 #include "../deps/switchres/switchres_wrapper.h"
 static sr_mode srm;
 #endif
@@ -59,7 +59,7 @@ static void crt_rpi_switch(videocrt_switch_t *p_switch,int width, int height, fl
 static bool crt_check_for_changes(videocrt_switch_t *p_switch)
 {
    if ((p_switch->ra_tmp_height != p_switch->ra_core_height) ||
-       (p_switch->ra_core_width != p_switch->ra_tmp_width) || 
+       (p_switch->ra_core_width != p_switch->ra_tmp_width) ||
        (p_switch->center_adjust != p_switch->tmp_center_adjust||
         p_switch->porch_adjust  != p_switch->tmp_porch_adjust ) ||
        (p_switch->ra_core_hz    != p_switch->ra_tmp_core_hz))
@@ -93,11 +93,11 @@ static void crt_aspect_ratio_switch(
          (float)p_switch->fly_aspect);
    RARCH_LOG("[CRT]: Setting Video Screen Size to: %dx%d \n",
          width, height);
-   video_driver_set_size(width , height); 
+   video_driver_set_size(width , height);
    video_driver_set_viewport(width , height,1,1);
 
    video_driver_apply_state_changes();
-   
+
 }
 
 static void set_aspect(videocrt_switch_t *p_switch,
@@ -143,26 +143,40 @@ static void set_aspect(videocrt_switch_t *p_switch,
    crt_aspect_ratio_switch(p_switch, scaled_width, scaled_height, srm_width, srm_height);
 }
 
-#if !defined(HAVE_VIDEOCORE) 
+static bool is_kms_driver_context()
+{
+   gfx_ctx_ident_t gfxctx;
+   video_context_driver_get_ident(&gfxctx);
+   RARCH_LOG("[CRT] Video context is: %s\n", gfxctx.ident);
+   if (strncmp(gfxctx.ident, "kms",3) == 0)
+      return true;
+   return false;
+}
+
+#if !defined(HAVE_VIDEOCORE)
 static bool crt_sr2_init(videocrt_switch_t *p_switch,
       int monitor_index, unsigned int crt_mode, unsigned int super_width)
 {
    const char* err_msg;
    char* mode;
    char index[10];
-  
+   int i;
+
    if (monitor_index+1 >= 0 && monitor_index+1 < 10)
       snprintf(index, sizeof(index), "%d", monitor_index);
    else
       strlcpy(index, "0", sizeof(index));
 
+   p_switch->kms_ctx = is_kms_driver_context();
+   i =  p_switch->kms_ctx ? 0 : 1;
+
    if (!p_switch->sr2_active)
    {
       sr_init();
 #if (__STDC_VERSION__ >= 199409L) /* no logs for C98 or less */
-      sr_set_log_callback_info(RARCH_LOG); 
-      sr_set_log_callback_debug(RARCH_DBG); 
-      sr_set_log_callback_error(RARCH_ERR); 
+      sr_set_log_callback_info(RARCH_LOG);
+      sr_set_log_callback_debug(RARCH_DBG);
+      sr_set_log_callback_error(RARCH_ERR);
 #endif
 
       switch (crt_mode)
@@ -192,14 +206,14 @@ static bool crt_sr2_init(videocrt_switch_t *p_switch,
       if (monitor_index+1 > 0)
       {
          RARCH_LOG("[CRT]: RA Monitor Index Manual: %s\n", &index[0]);
-         p_switch->rtn = sr_init_disp(index); 
+         p_switch->rtn = sr_init_disp(index, i);
          RARCH_LOG("[CRT]: SR Disp Monitor Index Manual: %s  \n", &index[0]);
       }
 
       if (monitor_index == -1)
       {
          RARCH_LOG("[CRT]: RA Monitor Index Auto: %s\n","auto");
-         p_switch->rtn = sr_init_disp("auto");
+         p_switch->rtn = sr_init_disp("auto", i);
          RARCH_LOG("[CRT]: SR Disp Monitor Index Auto: Auto  \n");
       }
 
@@ -211,10 +225,16 @@ static bool crt_sr2_init(videocrt_switch_t *p_switch,
          content_dir[0] = '\0';
       }
    }
-   
-   if (p_switch->rtn == 1)
+
+   if (p_switch->rtn == 1 && !p_switch->kms_ctx)
+   {
+      p_switch->sr2_active = true;
+      return true;
+   }
+   else if (p_switch->rtn == 1 && p_switch->kms_ctx)
    {
       p_switch->sr2_active = true;
+      RARCH_LOG("[CRT]: KMS context detected, keeping SR alive\n");
       return true;
    }
 
@@ -238,11 +258,14 @@ static void switch_res_crt(
    int w                   = native_width;
    int h                   = height;
    double rr               = p_switch->ra_core_hz;
+   settings_t *settings;
+   char crt_switch_timings[256];
+   char timing_backup[256];
 
    /* Check if SR2 is loaded, if not, load it */
-   if (crt_sr2_init(p_switch, monitor_index, crt_mode, super_width)) 
+   if (crt_sr2_init(p_switch, monitor_index, crt_mode, super_width))
    {
-      /* Check for core and content changes in case we need 
+      /* Check for core and content changes in case we need
          to make any adjustments */
       if (crt_switch_core_name())
          strlcpy(current_core_name, crt_switch_core_name(),
@@ -254,10 +277,10 @@ static void switch_res_crt(
             path_get(RARCH_PATH_CONTENT),
             sizeof(current_content_dir));
 
-      if (     !string_is_equal(core_name,   current_core_name) 
+      if (     !string_is_equal(core_name,   current_core_name)
             || !string_is_equal(content_dir, current_content_dir))
       {
-         /* A core or content change was detected, 
+         /* A core or content change was detected,
             we update the current values and make adjustments */
          strlcpy(core_name, current_core_name, sizeof(core_name));
          strlcpy(content_dir, current_content_dir, sizeof(content_dir));
@@ -266,7 +289,34 @@ static void switch_res_crt(
          crt_check_hh_core(p_switch);
       }
 
-      if (!(ret = sr_switch_to_mode(w, h, rr, interlace, &srm)))
+      if (p_switch->kms_ctx)
+      {
+         RARCH_LOG("[CRT]: KMS -> use sr_add_mode\n");
+         ret =   sr_add_mode(w, h, rr, interlace, &srm);
+         printf("Modeline is: %ld %d %d %d %d %d %d %d %d %f\n", srm.modeline.pclock,
+            srm.modeline.hactive, srm.modeline.hbegin, srm.modeline.hend, srm.modeline.htotal,
+            srm.modeline.vactive, srm.modeline.vbegin, srm.modeline.vend, srm.modeline.vtotal,
+            srm.modeline.vfreq);
+         settings_t *settings = config_get_ptr();
+
+         strcpy(timing_backup, settings->arrays.crt_switch_timings);
+         /* DRM modeline */
+         ret = sprintf(crt_switch_timings, "%ld %d %d %d %d %d %d %d %d %d %d",
+                   srm.modeline.pclock/1000,
+                   srm.modeline.hactive, srm.modeline.hbegin, srm.modeline.hend, srm.modeline.htotal,
+                   srm.modeline.vactive, srm.modeline.vbegin, srm.modeline.vend, srm.modeline.vtotal,
+                   (int)srm.modeline.vfreq, srm.interlace);
+         strcpy(settings->arrays.crt_switch_timings, crt_switch_timings);
+         crt_switch_driver_refresh();
+         //video_driver_set_video_mode(srm.width, srm.height, true);
+         strcpy(settings->arrays.crt_switch_timings, timing_backup);
+      } else {
+         ret =   sr_switch_to_mode(w, h, rr, interlace, &srm);
+      }
+
+      if(!p_switch->kms_ctx && !p_switch->kms_ctx)
+
+      if (!p_switch->kms_ctx && !(ret = sr_switch_to_mode(w, h, rr, interlace, &srm)))
          RARCH_LOG("[CRT]: SR failed to switch mode");
       p_switch->sr_core_hz = srm.refresh;
 
@@ -277,7 +327,7 @@ static void switch_res_crt(
    {
       set_aspect(p_switch, width , height, width, height,
             (float)1, (float)1, false);
-      video_driver_set_size(width , height); 
+      video_driver_set_size(width , height);
       video_driver_apply_state_changes();
    }
 }
@@ -295,9 +345,9 @@ void crt_destroy_modes(videocrt_switch_t *p_switch)
 static void crt_check_hh_core(videocrt_switch_t *p_switch)
 {
    p_switch->hh_core = false;
-} 
+}
 
-#if !defined(HAVE_VIDEOCORE) 
+#if !defined(HAVE_VIDEOCORE)
 static void crt_fix_hh_res(videocrt_switch_t *p_switch,
       int native_width, int width,  int height,
       int crt_mode, int monitor_index, int super_width)
@@ -380,7 +430,7 @@ void crt_switch_res_core(
       }
 
    }
-   
+
 }
 
 void crt_adjust_sr_ini(videocrt_switch_t *p_switch)
@@ -390,8 +440,8 @@ void crt_adjust_sr_ini(videocrt_switch_t *p_switch)
 
    if (p_switch->sr2_active)
    {
-      /* First we reload the base switchres.ini file 
-         to undo any overrides that might have been 
+      /* First we reload the base switchres.ini file
+         to undo any overrides that might have been
          loaded for another core */
       if (ini_overrides_loaded)
       {
@@ -402,7 +452,7 @@ void crt_adjust_sr_ini(videocrt_switch_t *p_switch)
 
       if (core_name[0] != '\0')
       {
-         /* Then we look for config/Core Name/Core Name.switchres.ini 
+         /* Then we look for config/Core Name/Core Name.switchres.ini
             and load it, overriding any variables it specifies */
          config_directory[0] = '\0';
          fill_pathname_application_special(config_directory,
@@ -473,21 +523,21 @@ static void crt_rpi_switch(videocrt_switch_t *p_switch,
    /* set core refresh from hz */
    video_monitor_set_refresh_rate(hz);
 
-   set_aspect(p_switch, width, 
+   set_aspect(p_switch, width,
       height, width, height,
       (float)1, (float)1, false);
 
    w = width;
-   while (w < 1920) 
+   while (w < 1920)
       w = w+width;
-   
+
    if (w > 2000)
          w =w- width;
-   
+
    width = w;
 
    crt_aspect_ratio_switch(p_switch, width,height,width,height);
-   
+
    /* following code is the mode line generator */
    hfp      = ((width * 0.044) + (width / 112));
    hbp      = ((width * 0.172) + (width /64));
diff --git a/gfx/video_crt_switch.h b/gfx/video_crt_switch.h
index da2bf60228..06eb4757f4 100644
--- a/gfx/video_crt_switch.h
+++ b/gfx/video_crt_switch.h
@@ -55,7 +55,7 @@ typedef struct videocrt_switch
    bool sr2_active;
    bool menu_active;
    bool hh_core;
-
+   bool kms_ctx;
 
 } videocrt_switch_t;
 
diff --git a/gfx/video_driver.c b/gfx/video_driver.c
index 1222dec4e3..d827ddb544 100644
--- a/gfx/video_driver.c
+++ b/gfx/video_driver.c
@@ -410,7 +410,7 @@ video_driver_state_t *video_state_get_ptr(void)
 
 void crt_switch_driver_refresh(void)
 {
-   video_driver_reinit(DRIVERS_CMD_ALL);
+   video_driver_reinit(DRIVER_VIDEO_MASK);
 }
 
 
